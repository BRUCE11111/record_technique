---
title: c++基础
top: false
cover: false
toc: true
mathjax: true
date: 2022-06-27 09:29:48
password:
summary:
tags: C++基础
categories: C++
---

# C++

[toc]

# 1. 关键字
## 1.1 const
### 1.1.1 const 的新花样

参考至：[(22条消息) const全局变量和局部变量的区别_weixin_45483780的博客-CSDN博客_const局部变量和全局变量](https://blog.csdn.net/weixin_45483780/article/details/107018603)

c语言中的const，需要重新读取内存对其进行赋值。所以，本质上是可以强制修改内容，只是语法上不能修改内容。

```c++
#include <stdio.h>

int main() {
	const int x = 10;
	int* p = (int*) &x;
	*p = 99;
	printf("%d", x);
	return 0;
}
```

const[全局变量](https://so.csdn.net/so/search?q=全局变量&spm=1001.2101.3001.7020)在静态区，直接或间接都不可以修改
const局部变量在栈上，可以间接修改
**但是定义为const的变量不建议修改**

> 作用域

c语言中的const和普通变量的唯一区别就是不能修改（语法上），其他无区别，使用extern在其他文件中也可以使用。

> 修改

c++ 在编译过程中就直接将值替换给变量，没有访问内存这一步，所以修改变量对于c++还是无效的，打印出来还是初始定义的值。

> 作用域

c++语言中const只能作用于本文件中，如果其他文件中使用，需要定义在头文件，其他文件引用头文件。

## 1.3 union

union是一种将各种不同的类型或数据结构放在一起共用一个地址的关键字。
有如下例子：

```c++
union S {
    int a;
    float b;
    uint64_t c;
}
```
这个例子中，变量a, b, c共用一个地址空间。这个Union命名的结构S，它的实际占用大小与成员中占用最大bit的成员一致。所以，在这里S实际上是个64bit的union。

再举个例子说明什么叫共用一个地址空间：
```c++
union S {
    int a[2];
    vector<int> vec;
}
void test() {
    S s.a[1] = 12; // 此时a是激活状态，可以使用变量a。
    
}

```

# 2. 类和对象

## 2.1 class和struct

类只是一个模板，不占用内存空间。对象是类的运行实例，其位于栈上或者堆上。

> 栈
>
> ```c++
> class demo {
>     private:
>     	string name;
>     public:
>     	string nickName;
> }
> 
> int main(){
>     // 栈上
>     demo d1;
>     d1.nickName = "hello";
>     // 堆上
>     demo *d2 = new demo;
>     d2 -> nickName = "hello";
>     
>     return 0;
> }
> 
> ```
==c++为了兼容c语言，保留了struct==

### 2.1.1 c语言中的struct

```c
struct A
{
	int a;
	int b;//成员列表
};
```

c语言设计理念是面向过程，面向过程中struct是一种数据类型，所以不能包含函数，否则编译器会报错。面向过程的变成认为数据和数据操作是分开的。

当struct进入c++，c++就认为数据和数据操作是一个整体，不应该分开。

所以，c++中的struct得到了很大的扩充：

* struct可以包括成员函数。
* struct可以实现继承。
* struct可以实现多态。

struct和class的区别：

1. 默认的继承访问权和访问权。class默认的是private，struct默认的是public。
2. class还可以用于定义模板参数，就像typename。但关键字struct不用于定义模板参数。
3. class和struct在使用大括号{}的区别：
   1. class和struct如果定义了构造函数，都不能使用大括号进行初始化。
   2. 没有定义构造函数，struct可以使用大括号初始化。
   3. 没有定义构造函数，且成员变量都是public，class可以使用大括号初始化。

### 2.1.2 注意使用事项

struct的复制，尽量自定义一个拷贝函数，否则在变量成员中有指针时，会浅拷贝，释放原拷贝值后会造成野指针。

[C++ 的浅拷贝和深拷贝（结构体） - 史D芬周 - 博客园 (cnblogs.com)](https://www.cnblogs.com/weekbo/p/8202754.html)

**当出现类的等号赋值时，会调用拷贝函数 在未定义显示拷贝构造函数的情况下，系统会调用默认的拷贝函数——即浅拷贝，它能够完成成员的一一复制。当数据成员中没有指针时，浅拷贝是可行的。 但当数据成员中有指针时，如果采用简单的浅拷贝，则两类中的两个指针将指向同一个地址，当对象快结束时，会调用两次析构函数，而导致指针悬挂现象。 所以，这时，必须采用深拷贝。 深拷贝与浅拷贝的区别就在于深拷贝会在堆内存中另外申请空间来储存数据，从而也就解决了指针悬挂的问题。 简而言之，当数据成员中有指针时，必须要用深拷贝。**



## 1.2 string

> 头文件
> 
使用string类需要包含头文件<string>:

```c++
void erase_demo() {
	string s1, s2, s3;
	s1 = s2 = s3 = "1234567890";
	s2.erase(5);
	s3.erase(5, 3);
	cout << s1 << endl;
	cout << s2 << endl;
	cout << s3 << endl;
}
```

### 1.2.1 string 内部是什么样的

c语言中，两种字符串的写法：

1. `char str[10] = "abc"` 这个字符串可读写.
2. `char *str = "abc"`，这个字符串只能读，不能写.

两种形式总是以"\0"作为结束标志。
c++ string隐藏了包含字符序列的物理表示，不需要关心数组的维数或者
`\0`方面的问题。

c++ 标准没有严格定义string类的内存布局，各个编译厂商可以提供不同的实现，但是必须保证string的行为是一致的。string内存分配规则，允许但不要求以引用计数(reference counting)的方式实现。

c++中，独立的几个string对象可以占据也可以不占据各自特定的物理存储区，但是，如果采用引用计数避免了保存同一数据的拷贝副本，那么各个独立对象
必须看起来并表现得就像独占存储区一样。
```c++
// #include<bits/stdc++.h>
#include <iostream>
#include <string>
using namespace std;

int main() {
    string s1("12345");
    string s2 = s1;
    cout << (s1 == s2) << endl;
    s1[0] = '6';
    cout << "s1 = " << s1 << endl;  // 62345
    cout << "s2 = " << s2 << endl;  // 12345
    cout << (s1 == s2) << endl;

    return 0;
}
```

在 GCC 下的运行结果：

```c++
s1 = 62345
s2 = 12345
0
```
只有当字符串被修改的时候才创建各自的拷贝，这种实现方式称为写时复制（copy-on-write）策略。当字符串只是作为值参数（value parameter）或在其他只读情形下使用，这种方法能够节省时间和空间。多线程中不可能使用引用计数的形式来进行实现，否则会引起冲突。

同时， COW(copy-on-write)并没有想象中的那么美好。


# 3. C++引用
c/c++ 禁止在函数调用时直接传递数组的内容，而是强制传递数组的指针。

对于结构体和对象，既可以传递指针也可以传递内容。为了提高效率，一般建议传递指针。

## 3.1 与指针的区别
1. 引用必须被初始化，但是不分配存储空间。指针不声明时初始化，在初始化的时候需要分配存储空间。
2. 引用初始化后不能被改变，指针可以改变所指的对象。
3. 不存在指向空值的引用，但是存在指向空值的指针。

从概念上讲。指针从本质上讲就是存放变量地址的一个变量，在逻辑上是独立的，它可以被改变，包括其所指向的地址的改变和其指向的地址中所存放的数据的改变。

而引用是一个别名，它在逻辑上不是独立的，它的存在具有依附性，所以引用必须在一开始就被初始化，而且其引用的对象在其整个生命周期中是不能被改变的（自始至终只能依附于同一个变量）。引用的主要功能是传递函数的参数和返回值。

指针变量在符号表上对应的地址值为指针变量的地址值，而引用在符号表上对应的地址值为 引用对象的地址值。符号表生成后就不会再改，因此指针可以改变其指向的对象（指针变量中的值可以改），而引用对象则不能修改。

“sizeof 引用”得到的是所指向的变量(对象)的大小，而“sizeof 指针”得到的是指针本身的大小；

## 3.2 注意点

同时，需要注意的是，引用不能指向临时数据。

其实 C++ 代码中的大部分内容都是放在内存中的，例如定义的变量、创建的对象、字符串常量、函数形参、函数体本身、new或malloc()分配的内存等，这些内容都可以用&来获取地址，进而用指针指向它们。除此之外，还有一些我们平时不太留意的临时数据，例如表达式的结果、函数的返回值等，它们可能会放在内存中，也可能会放在寄存器中。一旦它们被放到了寄存器中，就没法用&获取它们的地址了，也就没法用指针指向它们了。

下面的代码演示了表达式所产生的临时结果：
这些表达式的结果都会被放到寄存器中，尝试用&获取它们的地址都是错误的。

```c++
int n = 100, m = 200;
int *p1 = &(m + n);    //m + n 的结果为 300
int *p2 = &(n + 100);  //n + 100 的结果为 200
bool *p4 = &(m < n);   //m < n 的结果为 false
#include <iostream>
using namespace std;

int main() {
    int n = 100, m = 200;
    int *p1 = &(m);
    return 0;
}
```

## 3.3 绑定临时变量
c++ 引用不能绑定临时变量，但是将常引用绑定到临时数据时，编译器采取了一种妥协机制：编译器会为临时数据创建一个新的、无名的临时变量，并将临时数据放入该临时变量中，然后再将引用绑定到该临时变量。注意，临时变量也是变量，所有的变量都会被分配内存。

为什么编译器为常引用创建临时变量是合理的，而为普通引用创建临时变量就不合理呢？

1. 将引用绑定到一份数据后，就可以通过引用对这份数据进行操作了，包括读取和写入（修改）；尤其是写入操作，会改变数据的值。而临时数据往往无法寻址，是不能写入的，即使为临时数据创建了一个临时变量，那么修改的也仅仅是临时变量里面的数据，不会影响原来的数据，这样就使得引用所绑定到的数据和原来的数据不能同步更新，最终产生了两份不同的数据，失去了引用的意义。

2. const 引用和普通引用不一样，我们只能通过 const 引用读取数据的值，而不能修改它的值，所以不用考虑同步更新的问题，也不会产生两份不同的数据，为 const 引用创建临时变量反而会使得引用更加灵活和通用。

## 3.4 const引用和类型转换

参考至： http://www.cdsy.xyz/computer/programme/vc/20210105/cd16098262047569.html

编译器禁止指针指向不同类型的数据。
```c++
int n = 100;
int *p1 = &n;  //正确
float *p2 = &n;  //错误
char c = '@';
char *p3 = &c;  //正确
int *p4 = &c;  //错误
```

虽然 int 和 float 类型都占用 4 个字节的内存，但是程序对它们的处理方式却大相径庭：

对于 int，程序把最高 1 位作为符号位，把剩下的 31 位作为数值位；
对于 float，程序把最高 1 位作为符号位，把最低的 23 位作为尾数位，把中间的 8 位作为指数位。

「类型严格一致」是为了防止发生让人匪夷所思的操作，但是这条规则仅仅适用于普通引用，当对引用添加 const 限定后，情况就又发生了变化，编译器允许引用绑定到类型不一致的数据。

```c++
int n = 100;
int &r1 = n;  //正确
const float &r2 = n;  //正确
char c = '@';
char &r3 = c;  //正确
const int &r4 = c;  //正确 
```

临时变量的类型和引用的类型是一样的，在将数据赋值给临时变量时会发生自动类型转换。
```c++
float f = 12.45;
const int &r = f;
printf("%d", r);
```
但是，当引用的类型和数据的类型不遵守「数据类型的自动转换」规则，那么编译器将报错，绑定失败。

### 3.3.1 形参使用const修饰

同时，引用类型的形参，如果在函数中不发生改变，尽量使用const修饰。

```c++
#include <cstdio>
using namespace std;
double volume(const double &len, const double &width, const double &hei){
    return len*width*2 + len*hei*2 + width*hei*2;
}
int main(){
    int a = 12, b = 3, c = 20;
    double v1 = volume(a, b, c);
    double v2 = volume(10, 20, 30);
    double v3 = volume(89.4, 32.7, 19);
    double v4 = volume(a+12.5, b+23.4, 16.78);
    double v5 = volume(a+b, a+c, b+c);
    printf("%lf, %lf, %lf, %lf, %lf\n", v1, v2, v3, v4, v5);
    return 0;
}
```
概括起来说，将引用类型的形参添加 const 限制的理由有三个：

1. 使用 const 可以避免无意中修改数据的编程错误。
2. 使用 const 能让函数接收 const 和非 const 类型的实参，否则将只能接收非 const 类型的实参；
3. 使用 const 引用能够让函数正确生成并使用临时变量。

## 3.4 constexpr

### 3.4.1 解释

在编译阶段评估函数或者变量是否是常量。这个意思是，函数或者变量仅仅在编译阶段是常量表达式。

要求必须是字面类型( [literal types]([Trivial, standard-layout, POD, and literal types | Microsoft Learn](https://learn.microsoft.com/en-us/cpp/cpp/trivial-standard-layout-and-pod-types?view=msvc-160#literal_types)))。 在编译阶段就能够知道它的实际值是多少，而不是可能像const那样推迟到运行时才可能计算出来真正的值。

**在之前const就是被作为常量使用的，现在多了一个constexpr是不是多此一举呢？**

我们继续来看，了解一下const的作用：

（1）可以定义const常量，具有不可变性。 　　

例如：const int Max=100; Max++会产生错误; 　

（2）便于进行类型检查，使[编译器](https://link.juejin.cn?target=https%3A%2F%2Fbaike.sogou.com%2Flemma%2FShowInnerLink.htm%3FlemmaId%3D106869%26ss_c%3Dssc.citiao.link)对处理内容有更多了解，消除了一些隐患。 　　

例如： void f(const int i) { .........} 编译器就会知道i是一个常量，不允许修改；

（3）可以避免意义模糊的数字出现，同样可以很方便地进行参数的调整和修改。 同宏定义一样，可以做到不变则已，一变都变！

（4）可以保护被修饰的东西，防止意外的修改，增强程序的健壮性。

（5） 可以节省空间，避免不必要的内存分配。

const定义常量从汇编的角度来看，只是给出了对应的内存地址，而不是像#define一样给出的是立即数，所以，const定义的常量在程序运行过程中只有一份拷贝，而#define定义的常量在内存中有若干份拷贝。

从上面几个地方看const就是常量，那么我们进行一个小测试：

```go
const int len = 5;

int a[len];
复制代码
```

可能在现在编译器使用，它都是不报错的，因为已经经过了编译器优化，但是在老版本的编译器中往往会报错！

这是因为 C++ 标准中数组的长度必须是一个常量表达式，而对 于 len而言，这是一个 const 常数，而不是一个常量表达式，因此（即便这种行为在大部分编译器中 都支持，但是）它是一个非法的行为。

如果你想知道，这到底是为什么，可以看下这段我的总结，但是我不保证它百分百正确！

> 数组的长度需要常量定义，像是5、6、7这种肯定是常量，只读；因为常量是被编译器放在内存中的只读区域，当然也就不能够去修改它。
>
> 而const变量实在内存中存在的，只不过编译器不允许它被修改，毕竟const定义的变量，虽然被叫做常量，但是更细一点是被叫做”常值变量“，当作变量看待。

### 3.4.2 constexpr：常量表达式

**constexpr（常量表达式）：是指值不会改变并且在编译过程就能得到计算结果的表达式。**

**常量表达式的优点是将计算过程转移到编译时期，那么运行期就不再需要计算了，程序性能也就提升了。**

const好用，但是在某些情况下，我们还是会被它所谓的”常量“，给迷惑，产生错误用法，那既然如此，到底有没有真正的常量定义呢！

答案：有的。

C++11 提供了 constexpr 让用户显式的声明函数或对象构造函数在编译期会成为常量表达式，这 个关键字明确的告诉编译器应该去验证 constexpr定义的值在编译期就应该是一个常量表达式。

```ini
constexpr int len = 5;

int a[len];
复制代码
```

此时使用合法！

### 3.4.3 constexpr定义函数

```arduino
constexpr int Length_Constexpr()
{
    return 5;
}

char arr_2[Length_Constexpr() + 1]; // 合法
复制代码
```

constexpr返回值也是常量！

但是constexpr函数和正常函数肯定是不一样的，因为它需要在编译期做事，需要有一定的使用限制！

从C++11开始，constexpr函数不仅可以返回常量，还可以进行递归操作。

```arduino
constexpr int fibonacci(const int n) 
{
return n == 1 || n == 2 ? 1 : fibonacci(n-1)+fibonacci(n-2);
}
复制代码
```

从 C++14 开始，constexpr 函数可以在内部使用局部变量、循环和分支等简单语句。

```scss
constexpr int fibonacci(const int n) 
{
if(n == 1) return 1;
if(n == 2) return 1;
return fibonacci(n-1) + fibonacci(n-2);
}
```

## 3.5 左值和右值

*左值 (lvalue, locator value)* 表示了一个占据内存中某个可识别的位置（S也就是一个地址）的对象。

*右值 (rvalue)* 则使用排除法来定义。一个表达式不是 *左值* 就是 *右值* 。 那么，右值是一个 *不* 表示内存中某个可识别位置的对象的表达式。

上面的术语定义显得有些模糊，这时候我们就需要马上看一些例子。我们假设定义并赋值了一个整形变量：

```
int var;
var = 4;
```

赋值操作需要左操作数是一个左值。`var` 是一个有内存位置的对象，因此它是左值。然而，下面的写法则是错的：

```
4 = var;       // 错误！
(var + 1) = 4; // 错误！
```

常量 `4` 和表达式 `var + 1` 都不是左值（也就是说，它们是右值），因为它们都是表达式的临时结果，而没有可识别的内存位置（也就是说，只存在于计算过程中的每个临时寄存器中）。因此，赋值给它们是没有任何语义上的意义的——我们赋值到了一个不存在的位置。



# 4. C++继承和派生

public、protected、private 修饰类的成员，protected 成员和 private 成员类似，也不能通过对象访问。但是当存在继承关系时，protected 和 private 就不一样了：基类中的 protected 成员可以在派生类中使用，而基类中的 private 成员不能在派生类中使用。

1) 基类成员在派生类中的访问权限不得高于继承方式中指定的权限。例如，当继承方式为 protected 时，那么基类成员在派生类中的访问权限最高也为 protected，高于 protected 的会降级为 protected，但低于 protected 不会升级。再如，当继承方式为 public 时，那么基类成员在派生类中的访问权限将保持不变。

也就是说，继承方式中的 public、protected、private 是用来指明基类成员在派生类中的最高访问权限的。

2.）不管继承方式如何，基类中的 private 成员在派生类中始终不能使用（不能在派生类的成员函数中访问或调用）。

3.）如果希望基类的成员能够被派生类继承并且毫无障碍地使用，那么这些成员只能声明为 public 或 protected；只有那些不希望在派生类中使用的成员才声明为 private。

4.) 如果希望基类的成员既不向外暴露（不能通过对象访问），还能在派生类中使用，那么只能声明为 protected。

<font color = "red">我们这里说的是基类的 private 成员不能在派生类中使用，并没有说基类的 private 成员不能被继承。实际上，基类的 private 成员是能够被继承的，并且（成员变量）会占用派生类对象的内存，它只是在派生类中不可见，导致无法使用罢了。private 成员的这种特性，能够很好的对派生类隐藏基类的实现，以体现面向对象的封装性。</font>


# 5. 指针

## 5.1 数组到底在什么时候会转换为指针

数组名的本意是表示一组数据的集合，它和普通变量一样，都用来指代一块内存，但在使用过程中，数组名有时候会转为指向数据集合的指针（地址），而不是表示数据集合本身。

数据集合包含多个数据，直接使用一个集合没有任何意义，C语言中规定，当数组名作为数组定义的标识符（也就是定义或声明数组时）、sizeof或&的操作数时，它才表示整个数组本身，在其他表达式中，数组名会被转换为指向第0个元素的指针（地址）。

**数组下标[]**
C语言中规定数组下标和指针的偏移量相同，数组下标的引用总是可以写成“一个指向数组起始地址的指针加上偏移量”。假设现在有一个数组a和指针变量p，它们的定义形式为：
```c++
int a = {1, 2, 3, 4, 5}, *p, i = 2;
```
其实对于数组的引用`a[i]`会被i版一起改写成`*(a + i)`，C语言标准也要求编译器必须具备这种行为。

下标操作符 [ ]是建立在指针的基础上，它的作用是使一个指针和一个整数相加，产生出一个新的指针，然后从这个新指针（新地址）上取得数据；假设指针的类型为 T *，所产生的结果的类型就是 T。

使用下标时，编译器会自动把下标的步长调整到数组元素的大小。数组 a 中每个元素都是 `int` 类型，长度为 4 个字节，那么`a[i+1]`和 `a[i]`在内存中的距离是 4（而不是 1）。

这意味着下面这三种表示形式是一样的：

```c++
void func(int *parr){ ...... }
void func(int arr[]){ ...... }
void func(int arr[5]){ ...... }
```

# 6.STL

STL由容器、算法、迭代器、函数对象、适配器、内存分配器这6部分组成，其中后面4部分是为前面两部分服务的，他们各自的含义如表1所示。

| STL的组成  |                             含义                             |
| :--------: | :----------------------------------------------------------: |
|    容器    | 一些封装数据结构的模板类，例如vector向量容器、list列表容器等。 |
|    算法    | STL将常用的数据结构算法设计成一个个模板函数，这些算法在std命名空间中定义，其中大部分算法都包含在`<algorithm>`中，少部分位于头文件`<numeric>`中。 |
|   迭代器   |    对容器的读和写通过迭代器完成，容器和算法之间的胶合剂。    |
|  函数对象  | 如果一个类将`()`运算符重载为成员函数，这个类就称为函数对象类，这个类的对象就是函数对象（仿函数）。 |
|   适配器   | 可以使一个类的接口（模板参数）适配成用户指定的形式，从而让原本不能在一起工作的两个类工作在一起。容器、迭代器和函数都有适配器。 |
| 内存分配器 | 为容器类模板提供自定义的内存申请和释放功能，一般只有高级用户拥有改变内存分配策略的需求。 |

C++标准中有13个头文件：

|<iterator>|<functional>|<vector>|<deque>|<list>|<queue>|<stack>|<set>|<map>|<algorithm>|<numeric>|<memory>|<utility>|

==标准头文件不再有扩展名。（vector.h -> vector)==

## 6.1 序列式容器

> 是什么

模板类的集合，容器中封装的是组织数据的方法（数据结构）。有序列容器、排序容器和哈希容器。其中后两类称为关联容器。

| 容器种类 | 功能                                                         |
| -------- | ------------------------------------------------------------ |
| 序列容器 | 包括vector向量容器、list列表容器和deque双端队列容器。之所以是序列容器，是因为元素在容器内的位置和元素的值无关，容器不是排序的。将元素插入容器时，指定什么位置元素就会在什么位置。 |
| 排序容器 | 包括set集合容器、multiset多重集合容器、map映射容器以及multimap多重映射容器。排序容器中的元素默认是由小到大排序好的，即便是插入元素，元素也会插入到适当位置。所以关联容器在查找时具有非常好的性能。 |
| 哈希容器 | unordered_set哈希集合、unordered_multiset哈希多重集合、unordered_map哈希映射以及unordered_multimap哈希多重映射。未排序，元素位置由哈希函数确定。 |

### 6.1.1 迭代器

> 是什么

容器内部结构虽然不同，但是对于数据的查找、排序和求和等操作都是类似的。

完全利用泛型技术，将它们设计成适用所有容器的通用蒜贩，从而将容器和算法分开。

有输入迭代器、输出迭代器、前向迭代器、双向迭代器和随机访问迭代器5种。经常使用的是后三种。

* 前向迭代器

如果`p`是一个前向迭代器，则p支持`++p` `p++` `*p` 操作，还可以被复制或赋值，可以用 `==` 和 `!=` 运算符进行比较。此外，两个正向迭代器可以互相赋值。

* 双向迭代器

双向迭代器具有正向迭代器的全部功能，除此之外，假设p是一个双向迭代器，则还可以进行`--p`或者`p--`操作（即一次向后移动一个位置）。

* 随机访问迭代器

随机访问迭代器具有双向迭代器的全部功能。初次之前，还支持`p+=i` `p-=i` `p+i` `p-i` `p[i]`

容器迭代器的类型：

|               容器               | 对应的迭代器的类型 |
| :------------------------------: | :----------------: |
|              array               |   随机访问迭代器   |
|              vector              |   随机访问迭代器   |
|              deque               |   随机访问迭代器   |
|               list               |     双向迭代器     |
|           set/multiset           |     双向迭代器     |
|           map/multimap           |     双向迭代器     |
|           forward_list           |     前向迭代器     |
| unordered_map/unordered_multimap |     前向迭代器     |
| unordered-set/unorderd_multiset  |     前向迭代器     |
|              stack               |       不支持       |
|              queue               |       不支持       |

### 6.2.1 Array

> 是什么

在c++普通数组的基础上，添加了一些成员函数和全局函数。==比普通数组安全，且效率没有变差==

array大小固定，无法动态扩展或者收缩。只允许访问或者替换元素。

`const int *p`

`int const *p`

`const int const *p`





### 6.3.1 vector



### 6.3.1 deque

> 怎么做

实现原理：[C++ STL deque 容器底层实现原理（深度剖析） - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/562914205)





### 6.4.1 map

![C++ STL map部分成员方法示意图](C:\Users\xuxiaohu\OneDrive - Intel Corporation\blog\BRUCE11111.github.io\source\_posts\c-基础\2-19112Q14QE40.gif)

部分成员方法示意图。

`map`是双向迭代器，可以支持`++p p++ --p p-- *p`，迭代器之间只能使用`== !=`运算符比较。

#### 1. 成员方法

* find

  提供`find()`成员方法，帮我们查找指定key值的键值对，如果成功找到，则返回一个指向该键值对的双向迭代器。反之和`end()`方法相同。

  默认使用键的值，对键值进行升序排序。

* lower_bound(key) and upper_bound(key) and equal_range(key)

  lower是返回指向第一个不小于key的键值对迭代器。upper指向第一个键大于key的键值对的迭代器。

  `equal_range(key)`返回一个pair对象，其中的2个元素都是迭代器类型，其中`pair.first`是`lower_bound(key)`返回值，`pair.second`是`upper_bound(key)`返回值。







# 7. std tricky



## 7.1 类型转换

c++基本数据类型，可以分为：整形、浮点型、字符型和布尔型。其中数值型包括整形和浮点型。字符型就是char。

1. 将浮点型数据赋值给整形变量，舍弃小数部分。
2. 将整形数据赋值给浮点型变量时，数值不变，但是以指数形式存储。
3. 将double型数据赋值给float型变量时，注意数值范围溢出。
4. 字符型数据可以赋值给整形变量，此时存入的时字符的ASCII码。
5. 将一个int，short或long数据赋值给一个char型变量，只将低8位原封不动送到char型变量中。
6. 将有符号数据赋值给长度相同的无符号型变量，连同原来的符号位一起传送。



### 7.1.1 `const_pointer_cast`

参考至：[here](https://cplusplus.com/reference/memory/const_pointer_cast/)

将`shared_ptr`指针转为`const`类型的指针。

它的参数必须为shared_ptr类型的指针。:ice_cream:例子：

```c++
#include <iostream>
#include <memory>

int main () {
  std::shared_ptr<int> foo;
  std::shared_ptr<const int> bar;

  foo = std::make_shared<int>(10);

  bar = std::const_pointer_cast<const int>(foo);

  std::cout << "*bar: " << *bar << '\n';
  *foo = 20;
  std::cout << "*bar: " << *bar << '\n';

  return 0;
}
```

### 7.1.2 `static_cast`

强制将一种数据类型转换为另一种数据类型。例如将整形数据转换为浮点型数据。

```c++
int a = 10;
int b = 3;
double result = static_cast<double>(a) / static_cast<double>(b);
```

主要用法：

1. 用于类层次结构中基类和派生类之间指针或引用的转换。

   向上转型时安全的。向下转型，由于没有动态类型检查，是不安全的。

2. 用于基本数据类型之间的转换，如把int转为char。这种转换的安全也需要开发人员来保证。

3. 把空指针转换为目标类型的空指针。

4. 把任何类型的表达式转为void类型。

==static_cast不能转换掉表达式的const、volitale或__unaligned==

**static_cast:可以实现C++中内置基本数据类型之间的相互转换。**

如果涉及到类的话，static_cast只能在**有相互联系的类型中进行相互转换,**不一定包含虚函数。

### 7.1.3 const_cast

强制去除不能修改的const属性，但是不是用于去除变量的常量性，而是去除指向常数对象的指针或引用常量性，去除的常量性对象必须为指针或引用。

也就是说：
  常量指针被转化成非常量指针，并且仍然指向原来的对象；
  常量引用被转换成非常量引用，并且仍然指向原来的对象；常量对象被转换成非常量对象。

```c++
const int a = 10;
int b = const_cast<int>(a);  //compile error
```

























































